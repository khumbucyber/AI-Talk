◆◆◆◆◆ デモ1：LLM APIは「ステートレス」 ◆◆◆◆◆

(venv) r-igarashi@TN-IIJ7358:/mnt/c/Users/r-igarashi/code/AI-Talk/ai-talk-demo$ python3 demo1_stateless.py 

使い方: python demo1_stateless.py [デモ番号]

デモ番号:
    1-1    名前を伝える（「覚えました」と返る）
    1-2    名前を聞く（忘れている！）
    1-3    履歴を渡すと答えられる
    all    全て順番に実行

(venv) r-igarashi@TN-IIJ7358:/mnt/c/Users/r-igarashi/code/AI-Talk/ai-talk-demo$ python3 demo1_stateless.py 1-1
============================================================
【デモ1-1】名前を伝える
============================================================
📤 送信: 私の名前は良です。覚えておいてください。
------------------------------------------------------------
📥 応答:
良さん、よろしくお願いします！何かお手伝いできることがあれば教えてください。

(venv) r-igarashi@TN-IIJ7358:/mnt/c/Users/r-igarashi/code/AI-Talk/ai-talk-demo$ python3 demo1_stateless.py 1-2
============================================================
【デモ1-2】名前を聞く（別リクエスト = 履歴なし）
============================================================
📥 応答:
申し訳ありませんが、私は個別のユーザーの情報を記憶することはできません。毎回のやり取り📥 応答:


(venv) r-igarashi@TN-IIJ7358:/mnt/c/Users/r-igarashi/code/AI-Talk/ai-talk-demo$ python3 demo1_stateless.py 1-3
============================================================
【デモ1-3】履歴を含めて聞く（アプリがやっていること）
============================================================
📤 送信: 過去の会話履歴 + 新しい質問
------------------------------------------------------------
📥 応答:
あなたの名前は良（りょう）さんです。

◆◆◆◆◆ デモ2：LangChainで外部メモリ検索 ◆◆◆◆◆

(venv) r-igarashi@TN-IIJ7358:/mnt/c/Users/r-igarashi/code/AI-Talk/ai-talk-demo$ python3 demo2_langchain.py

使い方: python demo2_langchain.py [デモ番号]

デモ番号:
    2-1    外部メモリの内容を表示
    2-2    Docker関連の検索
    2-3    フロントエンド関連の検索
    2-4    検索結果をLLMに渡して回答生成
    all    全て順番に実行

(venv) r-igarashi@TN-IIJ7358:/mnt/c/Users/r-igarashi/code/AI-Talk/ai-talk-demo$ python3 demo2_langchain.py 2-1
============================================================
【デモ2-1】外部メモリ（過去の情報）を作成
============================================================
📝 外部メモリに保存された情報:
------------------------------------------------------------
  1. ユーザーはJavaとSpring Bootでバックエンド開発をしている
  2. 最近はマイクロサービスアーキテクチャに関心がある
  3. DockerとWSL2の環境で開発している
  4. Kafkaを使ったイベント駆動設計を勉強中
  5. フロントエンドはReactとTypeScriptを使用

✅ ベクトルDBに保存完了

(venv) r-igarashi@TN-IIJ7358:/mnt/c/Users/r-igarashi/code/AI-Talk/ai-talk-demo$ python3 demo2_langchain.py 2-2
============================================================
【デモ2-2】質問に関連する情報だけを検索
============================================================
🔍 質問: Dockerの開発環境を最適化したい
------------------------------------------------------------
📋 検索結果（関連度が高い情報）:
  1. DockerとWSL2の環境で開発している
  2. ユーザーはJavaとSpring Bootでバックエンド開発をしている

(venv) r-igarashi@TN-IIJ7358:/mnt/c/Users/r-igarashi/code/AI-Talk/ai-talk-demo$ python3 demo2_langchain.py 2-3
============================================================
【デモ2-3】別の質問で検索
============================================================
🔍 質問: フロントエンドの技術スタックについて教えて
------------------------------------------------------------
📋 検索結果（関連度が高い情報）:
  1. フロントエンドはReactとTypeScriptを使用
  2. 最近はマイクロサービスアーキテクチャに関心がある

(venv) r-igarashi@TN-IIJ7358:/mnt/c/Users/r-igarashi/code/AI-Talk/ai-talk-demo$ python3 demo2_langchain.py 2-4
============================================================
【デモ2-4】検索結果を使ってLLMに質問
============================================================
🔍 質問: Dockerの開発環境を最適化したい
------------------------------------------------------------
📋 LLMに渡したコンテキスト:
  DockerとWSL2の環境で開発している
ユーザーはJavaとSpring Bootでバックエンド開発をしている
------------------------------------------------------------
📥 LLMの応答:
Dockerの開発環境を最適化するためには、以下のポイントに注意することが重要です。特にJavaとSpring Bootのバックエンド開発においては、ビルド時間やパフォーマンスを改善するためのさまざまなテクニックがあります。

### 1. ベースイメージの選択
- **軽量なベースイメージを使用する**: `openjdk:11-jdk-slim` や `adoptopenjdk:11-jdk-hotspot` などの軽量なベースイメージを選ぶことで、イメージサイズを削減できます。

### 2. マルチステージビルドの活用
- **マルチステージビルドを利用する**: 不要なファイルを含まない最小限のイメージを作るために、ビルドと実行を別のステージで管理します。これにより、最終イ メージが軽量になります。

    ```Dockerfile
    FROM maven:3.8.1-openjdk-11 AS build
    WORKDIR /app
    COPY . .
    RUN mvn clean package -DskipTests

    FROM openjdk:11-jre-slim
    WORKDIR /app
    COPY --from=build /app/target/your-app.jar your-app.jar
    ENTRYPOINT ["java", "-jar", "your-app.jar"]
    ```

### 3. キャッシュの利用
- **Dockerレイヤーキャッシュを活用する**: 不変の依存関係を早めにCOPY命令でビルドし、頻繁に変更するアプリケーションコードは最後にCOPYします。これにより 、変更がない限り再ビルドを避けることができます。

    ```Dockerfile
    COPY pom.xml .
    RUN mvn dependency:go-offline

    COPY src/ src/
    RUN mvn package
    ```

### 4. Docker Composeの活用
- **Docker Composeを使って複数サービスを定義**: 開発環境でデータベースやメッセージブローカーなどの関連サービスを簡単に管理できます。

    ```yaml
    version: '3'
    services:
      app:
        build: .
        ports:
          - "8080:8080"
        volumes:
          - .:/app
        environment:
          SPRING_PROFILES_ACTIVE: dev
      db:
        image: postgres:13
        environment:
          POSTGRES_DB: mydatabase
          POSTGRES_USER: user
          POSTGRES_PASSWORD: password
        ports:
          - "5432:5432"
    ```

### 5. リソースの最適化
- **Dockerのリソース設定を見直す**: Docker Desktopの設定で、WSL2のリソース（メモリ、CPU、ディスクスペース）を適切に設定することで、パフォーマンスが向上します。

### 6. 開発用のプロファイルを利用
- **Spring Bootのプロファイル機能を使って開発環境を調整**: 開発専用の設定ファイル（`application-dev.yml` など）を利用することで、デバッグやテストがしやすくなります。

### 7. Hot Reloadの設定
- **Spring Boot DevToolsを使用する**: 開発中にコード変更が即時に反映されるようにするため、DevToolsを設定します。これにより、再起動せずにアプリケーショ ンをテストできるようになります。

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-devtools</artifactId>
    <optional>true</optional>
</dependency>
```

### 8. Docker Volumeの使用
- **ホストとコンテナ間でボリュームを使用する**: 開発中にファイルを共有するために、ボリュームを使用してホストのファイルシステムをマウントすることができ ます。
ます。

### 9. ログ管理
- **ログを標準出力に出力する**: Dockerでは、コンテナの標準出力を使ってログを収集します。Spring Bootの設定で、ログを標準出力にすることをお勧めします。  

これらの手法を組み合わせることで、Docker環境を大幅に改善し、開発の生産性を向上させることができます。具体的な要件によって適用する方法を選択し、最適な開 発フローを構築してください。

(venv) r-igarashi@TN-IIJ7358:/mnt/c/Users/r-igarashi/code/AI-Talk/ai-talk-demo$